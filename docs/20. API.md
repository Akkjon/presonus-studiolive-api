# API

## Discovery Client

> ES5

```js
const { Discovery } = require('presonus-studiolive-api')
```

> ES6

```js
import { Discovery } from 'presonus-studiolive-api
```

If you only want to search for devices on the network without the intention of connecting to them, you can run the discovery client independently.

* Instantiate the client
  * `new Discovery()`
* Attach `discover` event handler
  * `<Client>.on('discover', Function<DiscoveryType>)`
* Listen for discovery events (optional timeout)
  * `<Client>.start(timeout?: ms)`

```js
const discoveryClient = new Discovery()

discoveryClient.on('discover',
  (device) => {
    // device.name
    // device.serial
    // device.ip
    // device.port
    // device.timestamp
  }
})

// Discover indefinitely
discoveryClient.start()

 // Discover for 10 seconds
discoveryClient.start(10 * 1000)
```

---

## API Client

> ES5

```js
const { Client } = require('presonus-studiolive-api')
```

> ES6

```js
import Client from 'presonus-studiolive-api`
```

* `new Client(host: string, port: number = 53000)`  
Creates a Client object that will later connect to the console at `host`:`port`

* `<Client>.connect()`  
Connect to the console

* `<Client>.listen()`  
Start the metering server

* `<Client>.stop()`  
Stop the metering server

* `<Client>.setUDPServerPort(port: int)`  
Set the listen port of the metering server.  
Can only be run while the metering server is not running

* `<Client>.on(evtName: str, fn: function)`  
Listen for `evtName` events that will call `fn`



## Events

Events are split into Protocol Events (event codes that are part of the protocol), and custom events defined by this API.  

### Protocol Events

* `Hello`
* `JSON`
* `Setting`
* `Settings2`
* `FileResource`
* `FileResource2`
* `CompressedUnknown`

### Custom Events

* `connected` - Emitted when the client has successfully connected to the console
* `listening` - Emitted when the client has successfully started the meter server
* `meter` | `meterData` - Emitted when metering data is received

## Low(er) level access

* `client.emit(evtName: str, ...data)`  
Emits an event for `evtName` with `data`

* `client._sendPacket(messageCode: bytes[2], data, <customA>, <customB>)`  
Sends a packet to the server, messageCode is a two byte long string.  
`customA` is an optional single byte character  
`customB` is an optional single byte character  

* `client.conn` => TCP socket connection

## Metering

Metering is currently unavailable in the Node.js version -->

<!-- Metering data is stored as a dictionary -->


<!-- ```
{
  input: [..., ..., ... /* 32 */], // Input signal
  chain1input: input
  chain1output: [..., ..., ... /* 32 */], // First FX chain
  chain2input: chain1output,
  chain2output: [..., ..., ... /* 32 */], // Second FX chain
  chain3input: chain2output,
  chain3output: [..., ..., ... /* 32 */], // Third FX chain
  chain4input: chain3output,
  chain4output: [..., ..., ... /* 32 */], // Fourth FX chain
  level: chain4output
}
``` -->

---

